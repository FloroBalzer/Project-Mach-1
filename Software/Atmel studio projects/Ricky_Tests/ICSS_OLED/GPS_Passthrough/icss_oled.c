/**
 * \file
 *
 * \brief Application implement
 *
 * Copyright (c) 2015-2018 Microchip Technology Inc. and its subsidiaries.
 *
 * \asf_license_start
 *
 * \page License
 *
 * Subject to your compliance with these terms, you may use Microchip
 * software and any derivatives exclusively with Microchip products.
 * It is your responsibility to comply with third party license terms applicable
 * to your use of third party software (including open source software) that
 * may accompany Microchip software.
 *
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
 * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL MICROCHIP BE
 * LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL
 * LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
 * SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
 * POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE FULLEST EXTENT
 * ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY
 * RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *
 * \asf_license_stop
 *
 */
/*
 * Support and FAQ: visit <a href="https://www.microchip.com/support/">Microchip Support</a>
 */

#include "atmel_start.h"
#include "atmel_start_pins.h"
#include <stdio.h>
#include"oled.h"


#if CONF_USBD_HS_SP
static uint8_t single_desc_bytes[] = {
	/* Device descriptors and Configuration descriptors list. */
CDCD_ACM_HS_DESCES_LS_FS};
static uint8_t single_desc_bytes_hs[] = {
	/* Device descriptors and Configuration descriptors list. */
CDCD_ACM_HS_DESCES_HS};
#define CDCD_ECHO_BUF_SIZ CONF_USB_CDCD_ACM_DATA_BULKIN_MAXPKSZ_HS
#else
static uint8_t single_desc_bytes[] = {
	/* Device descriptors and Configuration descriptors list. */
CDCD_ACM_DESCES_LS_FS};
#define CDCD_ECHO_BUF_SIZ CONF_USB_CDCD_ACM_DATA_BULKIN_MAXPKSZ
#endif

static struct usbd_descriptors single_desc[]
= {{single_desc_bytes, single_desc_bytes + sizeof(single_desc_bytes)}
#if CONF_USBD_HS_SP
,
{single_desc_bytes_hs, single_desc_bytes_hs + sizeof(single_desc_bytes_hs)}
#endif
};

#define ICSS_Logo_width 128
#define ICSS_Logo_height 45
static unsigned char ICSS_Logo_bytes[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0xf0, 0xff, 0x01, 0xf0, 0x1f,
	0xe0, 0xff, 0x07, 0x00, 0x00, 0xfe, 0xff, 0x00, 0x10, 0x00, 0x00, 0xfe,
	0xff, 0x0f, 0xf8, 0x0f, 0xfc, 0xff, 0x3f, 0x00, 0x80, 0xff, 0xff, 0x07,
	0x38, 0x00, 0x00, 0xff, 0xff, 0x3f, 0xfc, 0x07, 0xfe, 0xff, 0xff, 0x00,
	0xe0, 0xff, 0xff, 0x1f, 0x38, 0x00, 0xc0, 0xff, 0xff, 0x3f, 0xfc, 0x83,
	0xff, 0xff, 0xff, 0x03, 0xf0, 0xff, 0xff, 0x7f, 0x38, 0x00, 0xe0, 0xff,
	0xff, 0x1f, 0xf0, 0xc1, 0xff, 0xff, 0xff, 0x03, 0xf8, 0xff, 0xff, 0x3f,
	0x38, 0x00, 0xf0, 0xff, 0xff, 0x0f, 0xf8, 0xc0, 0xff, 0xff, 0xff, 0x01,
	0xfc, 0xff, 0xff, 0x3f, 0x78, 0x00, 0xf8, 0xff, 0xc0, 0xc7, 0x4f, 0xe0,
	0x7f, 0x00, 0xfe, 0x01, 0xfc, 0x0f, 0xc0, 0x1f, 0x7c, 0x00, 0xfc, 0x1f,
	0x00, 0xe2, 0x07, 0xe0, 0x1f, 0x00, 0xf0, 0x00, 0xfc, 0x03, 0x00, 0x1e,
	0x7c, 0x00, 0xfe, 0x07, 0x00, 0xe0, 0x0f, 0xe0, 0x0f, 0x00, 0x40, 0x00,
	0xfe, 0x01, 0x00, 0x08, 0x7c, 0x00, 0xff, 0x01, 0x00, 0xe0, 0x0f, 0xf0,
	0x0f, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x7c, 0x00, 0xff, 0x00,
	0x00, 0xe0, 0x0f, 0xf0, 0x07, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00,
	0x7c, 0x80, 0x7f, 0x00, 0x00, 0xe0, 0x07, 0xf0, 0x07, 0x00, 0x00, 0x00,
	0xfe, 0x00, 0x00, 0x00, 0x7c, 0x80, 0x3f, 0x00, 0x00, 0xe4, 0x03, 0xf0,
	0x0f, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x7c, 0xc0, 0x3f, 0x00,
	0x00, 0x3e, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0xfe, 0x01, 0x00, 0x00,
	0x7c, 0xc0, 0x1f, 0x00, 0x00, 0x1f, 0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00,
	0xfe, 0x01, 0x00, 0x00, 0x7c, 0xc0, 0x1f, 0x00, 0x80, 0x3f, 0x00, 0xe0,
	0x3f, 0x00, 0x00, 0x00, 0xfe, 0x07, 0x00, 0x00, 0x7c, 0xc0, 0x1f, 0x00,
	0xc0, 0x7f, 0x00, 0xe0, 0xff, 0x03, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00,
	0x7c, 0xc0, 0x0f, 0x00, 0xe0, 0x3f, 0x00, 0xc0, 0xff, 0x3f, 0x00, 0x00,
	0xfc, 0xff, 0x07, 0x00, 0x7c, 0xe0, 0x0f, 0x00, 0xf0, 0x1f, 0x00, 0xc0,
	0xff, 0xff, 0x07, 0x00, 0xf8, 0xff, 0xff, 0x00, 0xfe, 0xe0, 0x0f, 0x00,
	0xe0, 0x0f, 0x00, 0x80, 0xff, 0xff, 0x1f, 0x00, 0xf0, 0xff, 0xff, 0x03,
	0xff, 0xe1, 0x0f, 0x00, 0xc0, 0x07, 0x00, 0x00, 0xfe, 0xff, 0x7f, 0x00,
	0xe0, 0xff, 0xff, 0x0f, 0xff, 0xe1, 0x0f, 0x00, 0x80, 0x03, 0x00, 0x00,
	0xf8, 0xff, 0xff, 0x01, 0x00, 0xff, 0xff, 0x1f, 0xff, 0xe1, 0x0f, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0x01, 0x00, 0xf8, 0xff, 0x3f,
	0xff, 0xc1, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x03,
	0x00, 0x00, 0xff, 0x7f, 0xff, 0xc1, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xff, 0x07, 0x00, 0x00, 0xe0, 0x7f, 0x00, 0xc0, 0x1f, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x07, 0x00, 0x00, 0x80, 0x7f,
	0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x07,
	0x00, 0x00, 0x00, 0xff, 0x7c, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0x00, 0xfe, 0x7c, 0x80, 0x7f, 0x00,
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0x00, 0xfe,
	0x7c, 0x00, 0xff, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x07,
	0x00, 0x00, 0x00, 0xfe, 0x7c, 0x00, 0xff, 0x01, 0x00, 0xf0, 0x03, 0x00,
	0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0x00, 0xfe, 0x7c, 0x00, 0xfe, 0x03,
	0x00, 0xf8, 0x07, 0x60, 0x00, 0x00, 0xf0, 0x07, 0x0c, 0x00, 0x00, 0xff,
	0x7c, 0x00, 0xfc, 0x0f, 0x00, 0xfe, 0x0f, 0xe0, 0x01, 0x00, 0xf8, 0x07,
	0x1e, 0x00, 0x00, 0x7f, 0x7c, 0x00, 0xfc, 0x7f, 0x80, 0xff, 0x07, 0xf0,
	0x07, 0x00, 0xfe, 0x07, 0x7e, 0x00, 0xc0, 0x7f, 0x7c, 0x00, 0xf8, 0xff,
	0xff, 0xff, 0x03, 0xf8, 0x3f, 0x80, 0xff, 0x03, 0xff, 0x07, 0xf8, 0x7f,
	0x7c, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x01, 0xf8, 0xff, 0xff, 0xff, 0x81,
	0xff, 0xff, 0xff, 0x3f, 0x7c, 0x00, 0xc0, 0xff, 0xff, 0xff, 0x00, 0xf8,
	0xff, 0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0x1f, 0x7c, 0x00, 0x80, 0xff,
	0xff, 0x3f, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x00, 0xfe, 0xff, 0xff, 0x0f,
	0x7c, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0x3f, 0x00,
	0xf8, 0xff, 0xff, 0x07, 0x7c, 0x00, 0x00, 0xf0, 0xff, 0x03, 0x00, 0x00,
	0xfe, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0x01, 0x7c, 0x00, 0x00, 0x00,
	0x1e, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x01, 0x00, 0x00, 0xfe, 0x1f, 0x00 };

volatile bool usb_connected = false;
volatile bool usb_out_busy = false;
uint32_t bus_number = 0;

/** Buffers to receive and echo the communication bytes. */
static char From_USB_buffer[CDCD_ECHO_BUF_SIZ];
static char To_USB_buffer[CDCD_ECHO_BUF_SIZ];


/** Ctrl endpoint buffer */
static uint8_t ctrl_buffer[64];

int iOLEDAddr = 0x3c; 
int bFlip = 0, bInvert = 0;


/**
 * \brief Callback invoked when bulk IN data received
 */
static bool usb_device_cb_bulk_in(const uint8_t ep, const enum usb_xfer_code rc, const uint32_t count)
{
	usb_out_busy = false;
	
	/* No error. */
	return false;
}

/**
 * \brief Callback invoked when bulk OUT data received
 */
static bool usb_device_cb_bulk_out(const uint8_t ep, const enum usb_xfer_code rc, const uint32_t count)
{
	
	

	/* No error. */
	return false;
}
/**
 * \brief Callback invoked when Line State Change
 */
static bool usb_device_cb_state_c(usb_cdc_control_signal_t state)
{
	if (state.rs232.DTR) {
		/* Callbacks must be registered after endpoint allocation */
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)usb_device_cb_bulk_out);
		cdcdf_acm_register_callback(CDCDF_ACM_CB_WRITE, (FUNC_PTR)usb_device_cb_bulk_in);	
		cdcdf_acm_read((uint8_t *)From_USB_buffer, sizeof(From_USB_buffer));
		usb_connected = true;
		sprintf(To_USB_buffer, "\r\nI2C_OLED_Test\r\n");
		usb_out_busy=true;
		cdcdf_acm_write((uint8_t *)To_USB_buffer, strlen(To_USB_buffer));
	}

	/* No error. */
	return false;
}

static void tx_cb_USART_0(const struct usart_async_descriptor *const io_descr)
{
	/* USART_0_ Transmit completed */
	
}

static void rx_cb_USART_0(const struct usart_async_descriptor *const io_descr)
{
	/* USART_0 character received */
	
}


int main(void)
{
	
	
	
	atmel_start_init();
	
	// Setup USART
		struct io_descriptor *gpsio;
		
		usart_async_register_callback(&USART_0, USART_ASYNC_TXC_CB, tx_cb_USART_0);
		usart_async_register_callback(&USART_0, USART_ASYNC_RXC_CB, rx_cb_USART_0);
		/*usart_async_register_callback(&USART_0, USART_ASYNC_ERROR_CB, err_cb_USART_0);*/
		usart_async_get_io_descriptor(&USART_0, &gpsio);
		//usart_async_enable(&USART_0);
		
	// Setup internal I2C Bus
	
		i2c_m_sync_set_baudrate(&I2C_0,0,100000);
		i2c_m_sync_enable(&I2C_0);
		
	// Setup external I2C Bus
		
		i2c_m_sync_set_baudrate(&I2C_1,0,100000);
		i2c_m_sync_enable(&I2C_1);
		
		
	// Start USB
	/* usb stack init */
	
		usbdc_init(ctrl_buffer);

		/* usbdc_register_funcion inside */
		cdcdf_acm_init();

		usbdc_start(single_desc);
		usbdc_attach();
		
	// Wait until USB enabled
		while (!cdcdf_acm_is_enabled()) {
			// wait cdc acm to be installed
		};

		cdcdf_acm_register_callback(CDCDF_ACM_CB_STATE_C, (FUNC_PTR)usb_device_cb_state_c);
		
	// Initalise and clear OLED display
			
		oled_Init();
		oled_SetPageMode();           //Set addressing mode to Page Mode
		oled_ClearDisplay(); // fill with black
		oled_SetNormalDisplay();      //Set display to normal mode (i.e non-inverse mode)	
		oled_DrawBitmap(&ICSS_Logo_bytes[0], 6);
		oled_SetTextXY(7,0);          //Set the cursor to Xth Page, Yth Column
		oled_PutString("Flight Computer"); //Print the String
		
	
	while (1) {
		if(usb_connected){
			while(usb_out_busy);
			sprintf(To_USB_buffer, "Test Running...\r\n");	
			usb_out_busy=true;	
			cdcdf_acm_write((uint8_t *)To_USB_buffer, strlen(To_USB_buffer));	
		}
			delay_ms(2000);
	}
}
